const db = require('../config/db');

// --- CLIENTS ---
exports.getClients = async (req, res) => {
    try {
        const [rows] = await db.query('SELECT * FROM clients ORDER BY created_at DESC');
        res.json(rows);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

exports.createClient = async (req, res) => {
    const { id, name, company, phone, email, address, city } = req.body;
    try {
        await db.query(
            'INSERT INTO clients (id, name, company, phone, email, address, city) VALUES (?, ?, ?, ?, ?, ?, ?)',
            [id, name, company, phone, email, address, city] // Assuming ID is generated by frontend UUID
        );
        res.json({ message: 'Client created' });
    } catch (err) {
        // If ID column is auto-increment in DB but frontend sends UUID, we might have a mismatch.
        // My schema.sql defined IDs as INT AUTO_INCREMENT. 
        // Frontend uses strings (UUIDs).
        // I should probably adjust the schema or the logic.
        // Let's check schema.sql first.
        res.status(500).json({ error: err.message });
    }
};

exports.updateClient = async (req, res) => {
    const { id } = req.params;
    const { name, company, phone, email, address, city } = req.body;
    try {
        await db.query(
            'UPDATE clients SET name=?, company=?, phone=?, email=?, address=?, city=? WHERE id=?',
            [name, company, phone, email, address, city, id]
        );
        res.json({ message: 'Client updated' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

exports.deleteClient = async (req, res) => {
    const { id } = req.params;
    try {
        await db.query('DELETE FROM clients WHERE id=?', [id]);
        res.json({ message: 'Client deleted' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};


// --- ORDERS ---
exports.getOrders = async (req, res) => {
    try {
        const [rows] = await db.query('SELECT * FROM orders ORDER BY created_at DESC');
        // Need to map DB snake_case to frontend camelCase if necessary, 
        // or ensure frontend handles snake_case.
        // Let's map it here to be safe and match frontend types.
        const orders = rows.map(r => ({
            id: r.id,
            orderNumber: r.order_number,
            clientId: r.client_id,
            orderDate: r.order_date,
            deliveryDate: r.delivery_date,
            serviceType: r.service_type,
            workDescription: r.work_description,
            documentType: r.document_type,
            documentNumber: r.document_number,
            price: r.price,
            advance: r.advance,
            isPrepaid: r.is_prepaid,
            totalPaid: r.total_paid,
            status: r.status,
            comments: r.comments,
            discount: r.discount,
            taxRate: r.tax_rate,
            validUntil: r.valid_until,
            priority: r.priority,
            createdAt: r.created_at
        }));
        res.json(orders);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

exports.createOrder = async (req, res) => {
    // Frontend sends a full object.
    // DB expects snake_case columns.
    const o = req.body;
    try {
        // Warning: ID in frontend is string, ID in DB is INT AUTO_INCREMENT.
        // If frontend generates ID, we might ignore it and let DB handle it, 
        // OR change DB to VARCHAR. 
        // Changing DB to VARCHAR(36) for IDs is safer to support UUIDs from frontend.
        // BUT for now, let's assume we restart and update SCHEMA to support UUIDs 
        // OR we just map DB ID back to frontend.

        await db.query(
            `INSERT INTO orders (
                order_number, client_id, order_date, delivery_date, service_type, 
                work_description, document_type, document_number, price, advance, 
                is_prepaid, total_paid, status, comments, discount, tax_rate, 
                valid_until, priority
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                o.orderNumber, o.clientId, o.orderDate, o.deliveryDate, o.serviceType,
                o.workDescription, o.documentType, o.documentNumber, o.price, o.advance,
                o.isPrepaid, o.totalPaid, o.status, o.comments, o.discount, o.taxRate,
                o.validUntil, o.priority
            ]
        );
        res.json({ message: 'Order created' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

exports.updateOrder = async (req, res) => {
    const { id } = req.params;
    const o = req.body;
    try {
        await db.query(
            `UPDATE orders SET 
                client_id=?, order_date=?, delivery_date=?, service_type=?, 
                work_description=?, document_type=?, document_number=?, price=?, advance=?, 
                is_prepaid=?, total_paid=?, status=?, comments=?, discount=?, tax_rate=?, 
                valid_until=?, priority=?
             WHERE id=?`,
            [
                o.clientId, o.orderDate, o.deliveryDate, o.serviceType,
                o.workDescription, o.documentType, o.documentNumber, o.price, o.advance,
                o.isPrepaid, o.totalPaid, o.status, o.comments, o.discount, o.taxRate,
                o.validUntil, o.priority, id
            ]
        );
        res.json({ message: 'Order updated' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

exports.deleteOrder = async (req, res) => {
    const { id } = req.params;
    try {
        await db.query('DELETE FROM orders WHERE id=?', [id]);
        res.json({ message: 'Order deleted' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};


// --- APPOINTMENTS ---
exports.getAppointments = async (req, res) => {
    try {
        const [rows] = await db.query('SELECT * FROM appointments ORDER BY appointment_date ASC');
        const appointments = rows.map(r => ({
            id: r.id,
            clientId: r.client_id,
            date: r.appointment_date,
            time: r.appointment_time,
            serviceType: r.service_type,
            notes: r.notes,
            status: r.status,
            reminderSent: r.reminder_sent
        }));
        res.json(appointments);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

exports.createAppointment = async (req, res) => {
    const a = req.body;
    try {
        await db.query(
            `INSERT INTO appointments (client_id, appointment_date, appointment_time, service_type, notes, status, reminder_sent)
             VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [a.clientId, a.date, a.time, a.serviceType, a.notes, a.status, a.reminderSent]
        );
        res.json({ message: 'Appointment created' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

exports.updateAppointment = async (req, res) => {
    const { id } = req.params;
    const a = req.body;
    try {
        await db.query(
            `UPDATE appointments SET client_id=?, appointment_date=?, appointment_time=?, service_type=?, notes=?, status=?, reminder_sent=? WHERE id=?`,
            [a.clientId, a.date, a.time, a.serviceType, a.notes, a.status, a.reminderSent, id]
        );
        res.json({ message: 'Appointment updated' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

exports.deleteAppointment = async (req, res) => {
    const { id } = req.params;
    try {
        await db.query('DELETE FROM appointments WHERE id=?', [id]);
        res.json({ message: 'Appointment deleted' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};
